/*
============================================================================
                    MASTER "this" CHEAT SHEET
              C++ vs JavaScript (Dynamic vs Lexical)
============================================================================

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1ï¸âƒ£  C++ MENTAL MODEL (STATIC & LEXICAL)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ 'this' is a constant pointer to the current object.
â€¢ It is determined at compile-time.
â€¢ Always refers to the instance that invoked the method.
â€¢ Lambdas must EXPLICITLY capture it using [this].

Example:

class Player {
    int hp = 100;

public:
    void show() {
        std::cout << this->hp << std::endl; // Always correct

        auto lambda = [this]() {
            std::cout << this->hp << std::endl; // Must capture explicitly
        };

        lambda();
    }
};

C++ Rule:
    âœ” Predictable
    âœ” Static binding
    âœ” Always instance-bound
    âœ” No runtime confusion


============================================================================
2ï¸âƒ£  JAVASCRIPT MENTAL MODEL
============================================================================

JavaScript has TWO behaviors for 'this':

A) Regular Functions  â†’  DYNAMIC binding
B) Arrow Functions    â†’  LEXICAL binding


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
A) REGULAR FUNCTION â†’ DYNAMIC (THE "CALLER RULE")
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Rule:
    'this' depends on WHO calls the function.
    (Object to the LEFT of the dot.)

Example:

const bot = {
    name: "Robo",
    greet: function() {
        console.log(this.name);
    }
};

bot.greet(); 
// âœ” "Robo"  (Called by bot)

const loose = bot.greet;
loose(); 
// âŒ undefined (Lost context â€“ now global/undefined)


Nested Trap:

const obj = {
    label: "Main",
    method: function() {

        function inner() {
            console.log(this.label);
        }

        inner(); 
        // âŒ undefined
        // Because inner() was NOT called with obj.inner()
    }
};

obj.method();


Fix Options:
    âœ” bind()
    âœ” call()
    âœ” apply()
    âœ” store outer 'this' in variable (old school)
    âœ” use arrow function


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
B) ARROW FUNCTION â†’ LEXICAL (THE "LOOK-UP RULE")
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Rule:
    Arrow functions DO NOT have their own 'this'.
    They LOOK UP to the nearest parent function.

Example:

const tracker = {
    count: 0,
    start: function() {

        const arrow = () => {
            this.count++;
            console.log(this.count);
        };

        arrow(); // âœ” Works
    }
};

tracker.start(); 
// âœ” 1


Why it works:
    arrow inherits 'this' from start()
    start() was called by tracker
    So arrow uses tracker


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ THE OBJECT TRAP
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Objects DO NOT create scope.
Only functions create scope.

Example:

const user = {
    name: "Alice",
    badGreet: () => {
        console.log(this.name);
    }
};

user.badGreet();
// âŒ undefined
// Because arrow looks UP to global scope
// It does NOT bind to user


Correct Way:

const user2 = {
    name: "Alice",
    greet: function() {
        console.log(this.name);
    }
};

user2.greet(); 
// âœ” "Alice"


============================================================================
3ï¸âƒ£  EXPRESS / NODE EXAMPLE
============================================================================

Arrow is SAFE in callbacks when you want lexical behavior:

const express = require("express");
const app = express();

app.get("/", (req, res) => {
    res.send("Server is active!");
});

app.listen(3000, () => {
    console.log("Server running");
});

Why arrow works here:
    We DON'T need dynamic 'this'
    We rely on closure, not object binding


============================================================================
4ï¸âƒ£  BROWSER EVENT EXAMPLE
============================================================================

<button id="btn">Click</button>

<script>
const button = document.getElementById("btn");

button.addEventListener("click", function() {
    console.log(this); 
    // âœ” this = button (Dynamic)
});

button.addEventListener("click", () => {
    console.log(this);
    // âŒ this = window (Lexical)
});
</script>


============================================================================
5ï¸âƒ£  SUMMARY TABLE
============================================================================

| Feature              | Regular Function | Arrow Function | C++ Method |
|----------------------|------------------|---------------|------------|
| Binding Type         | Dynamic          | Lexical       | Static     |
| Has its own 'this'?  | Yes              | No            | Yes        |
| Depends on caller?   | Yes              | No            | No         |
| Nested safe?         | No               | Yes           | Yes        |
| Needs capture?       | No               | No            | Yes ([this]) |
| Best for             | Object methods   | Callbacks     | OOP        |


============================================================================
ğŸ”¥ FINAL RULES TO REMEMBER
============================================================================

C++:
    'this' = always instance (safe, static)

JS Regular Function:
    'this' = whoever CALLS it

JS Arrow Function:
    'this' = whoever ENCLOSED it

Golden Rule:
    If you need dynamic object binding â†’ use regular function
    If you need parent scope binding â†’ use arrow function


============================================================================
END OF MASTER CHEAT SHEET
============================================================================
*/
